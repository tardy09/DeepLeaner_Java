方法wait的作用是使得当前正在执行的线程处于等待状态，该方法
预执行队列里面，并且在wait()所在的代码处停止执行直到接到通知
或者被中断为止
      在调用wait()方法之前，线程必须获得线程的对象级别锁，也就是说
      只能在同步方法或者同步代码块里面调用wait()
      在从wait()返回前，线程和其他线程竞争重新获得锁

      方法notify()也要在同步方法或者同步块里面进行调用，也就是在调用前，线程
      必须获得该对象级别锁

      如果有多个线程进行等待，则由线程规划器随机挑选一个呈wait状态的线程
      对其发出notify,并使得他等待获取该对象锁。
      需要注意的是，执行notify方法之后，当前的线程并不会马上释放对象锁，
      呈wait状态的线程也不会马上获得该对象锁，而是要等到执行
      notify方法的线程将程序执行完，也就是退出synchronized代码块之后，当前的线程才会释放锁，
      而呈wait状态的线程才可以获取到该对象锁。
      如果当第一个获得该对象的wait线程运行完毕以后，他会释放该对象锁，此时如果该对象没有再次使用
      notify语句，那么即便该线程已经空闲，其他的处于wait状态的线程由于没有
      得到该对象的通知，还会继续阻塞在wait状态，直到这个对象发出一个notify通知或者notifyall().
      一言以蔽之：
      wait()使得线程运行停止，而notify使得停止的线程得以继续运行。

         方法wait被执行后会导致锁被自动释放，但是执行了notify()方法之后
         锁却不会自动释放。必须执行完notify所在的同步synchronized代码块之后，才会释放锁。




wait()是Object的方法，意思是放弃已经拥有的当前对象的锁，然后在对象的等候队列上等待，让别的线程来唤醒它。
有点像操作系统里面的“管程”的概念，做得比较优雅。


  每个锁对象都具有两个队列一个就绪队列一个阻塞队列
  就绪队列存储了即将哟获得锁的队列
  而阻塞队列存储了被阻塞的线程
  一个线程被唤醒以后才会进入就绪队列，等待cpu的调度，
  反之，一个线程被wait之后，就会进入阻塞队列，等待下一次被唤醒



  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  runnable和running状态可以互相切换，因为可能线程运行了一段时间以后，有其他高优先级的线程抢占了cpu资源
  ，这个时候线程就从runnning态变成lrunnable态
  线程进入runnable态分为5种情况：
    1.调用sleep方法后经过的时间超时了
    2.线程调用阻塞io已经返回，阻塞方法执行完毕
    3.线程成功的获得了视图同步的监视器
    4.线程正在等待某个通知，其他线程发出了通知
    5，处于挂起的线程调用了resume恢复了方法

   Blocked 是阻塞的意思，例如遇到了一个io操作，此时cpu处于空闲的状态
   可能会把cpu时间片分配给其他的线程，这时候可以成为暂停的状态
   Blocked状态结束后进入了runnable状态，等待系统重新的分配资源

    出现阻塞的情况：
      1.线程调用了sleep方法，主动的放弃了占用的cpu资源
      2.线程调用了阻塞式IO方法，该方法在返回前，该线程被阻塞
      3，线程试图获得一个同步监视器，但是该监视器正在被其他的线程所持有
      4.线程等待某个通知
      5，程序调用了sunspend方法将该线程挂起，此方法容易导致死锁，所以不建议使用

    run方法运行结束后进入销毁阶段--整个线程执行完毕

