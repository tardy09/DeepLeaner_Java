取消/关闭的场景
我们知道，通过线程的start方法启动一个线程后，线程开始执行run方法，run方法运行结束后线程退出，那为什么还需要结束一个线程呢？有多种情况，比如说：
很多线程的运行模式是死循环，比如在生产者/消费者模式中，消费者主体就是一个死循环，它不停的从队列中接受任务，执行任务，在停止程序时，我们需要一种"优雅"的方法以关闭该线程。
在一些图形用户界面程序中，线程是用户启动的，完成一些任务，比如从远程服务器上下载一个文件，在下载过程中，用户可能会希望取消该任务。
在一些场景中，比如从第三方服务器查询一个结果，我们希望在限定的时间内得到结果，如果得不到，我们会希望取消该任务。
有时，我们会启动多个线程做同一件事，比如类似抢火车票，我们可能会让多个好友帮忙从多个渠道买火车票，只要有一个渠道买到了，我们会通知取消其他渠道。

取消/关闭的机制
Java的Thread类定义了如下方法：
public final void stop()

这个方法看上去就可以停止线程，但这个方法被标记为了过时，简单的说，我们不应该使用它，可以忽略它。
在Java中，停止一个线程的主要机制是中断，中断并不是强迫终止一个线程，它是一种协作机制，是给线程传递一个取消信号，但是由线程来决定如何以及何时退出，本节我们主要就是来理解Java的中断机制。

Thread类定义了如下关于中断的方法：
public boolean isInterrupted()
public void interrupt()
public static boolean interrupted()

这三个方法名字类似，比较容易混淆，我们解释一下。isInterrupted()和interrupt()是实例方法，调用它们需要通过线程对象，interrupted()是静态方法，实际会调用Thread.currentThread()操作当前线程。

每个线程都有一个标志位，表示该线程是否被中断了。
isInterrupted：就是返回对应线程的中断标志位是否为true。
interrupted：返回当前线程的中断标志位是否为true，但它还有一个重要的副作用，就是清空中断标志位，也就是说，连续两次调用interrupted()，第一次返回的结果为true，第二次一般就是false (除非同时又发生了一次中断)。


interrupt()对线程的影响与线程的状态和在进行的IO操作有关，我们先主要考虑线程的状态：
RUNNABLE：线程在运行或具备运行条件只是在等待操作系统调度
WAITING/TIMED_WAITING：线程在等待某个条件或超时
BLOCKED：线程在等待锁，试图进入同步块
NEW/TERMINATED：线程还未启动或已结束