把一个数据存储空间划分成两个部分，一部分用于存储人的，另一个部分用于存储人的性别，
这里的引用包含两个线程，一个线程向数据存储空间添加数据（生成者）
一个线程用于从数据空间取出数据（消费者），这个程序有两个意外需要考虑：
1.假设生产者线程刚向数据存储空间加入了一个人的姓名，还没有加入这个人的性别
，cpu就切换到了消费者线程，消费者线程则把这个人的姓名和上一个人的性别联系到了一起。
2.第二种意外：生成者放入了若干的数据，消费者才开始取出数据，或者是，消费者取完一个
数据后，还没等到生产者加入新的数据，又重复取出已经取过的数据。

另外 还需要保证 producer放入一次数据，那么consumer就读取一次数据
反之，producer也必须等到consumer读取完数据之后才能够放入新的数据
而这一问题的解决，就需要使用继承自Object类的wait、notify、notifyAll这几个方法
来实现线程间的通信，又因为所有的类都是自Object继承而来的，所以任何类都是自
Object继承而来。
  wait:告诉当前的线程放弃监视器并且进入睡眠状态，直到其他线程进入同一个
  监视器并调用notify方法为止，
  notify:唤醒同一个监视器中调用wait的第一个线程，这类似排队买票，这类似于排队买票，
  一个人买完后面的人才可以买
  notify方法将等待队列里面的一个等待线程从等待队列中移动到同步队列里面
  而notifyAll()方法则是将等待队列中的所有的线程全部的移动到同步队列里面
  ，被移动的同步线程的状态从WAITING变为BLOCKED。
  notifyAll:唤醒同一个对象监视器里面调用的wait的所有线程,具有最高优先级的线程
  首先被唤醒和执行。

另外 ，需要注意的是wait,notify,notifyAll这三个方法只能在synchronized方法里面调用
，也就是无论线程调用一个对象的wait还是notify方法，该线程必须先得到对象的锁标记。
这样，notify就只能唤醒同一对象监视器中调用wait的线程，而使多的个对象监视器，
就可以分别有多个wait、notify的情况，同组里的wait也只能被同组的notify唤醒。

    一个线程的等待和唤醒流程如下：
                           Thread t

，                        synchronized(this)<----线程t得到对象的锁标记

                            wait()<----------此时线程t被放置在对象的等待线程池中，t自动释放对象的锁标记

                            notify<-------- 当另外的线程执行了对象的notify方法后，
                            线程t就可能会被从对象的等待线程池里面释放出来，并且移动到
                            等待线程对象的锁标记的线程池里面，当t得到锁的标记就会执行下去。

……………………………………………………………………………………………………………………………………………………
                     ………………………………………………………………………………………………………………………………………………………………………………
                     java程序开始运行具有自己的栈空间，java支持多个线程访问一个对象或者对象的成员变量
                     由于每个线程可以拥有该变量的拷贝（虽然对象以及成员变量分配的内存是在共享内存里面的，但是
                     每个执行的线程还是可以拥有一份拷贝的，这样做的目的是加速程序的执行，这是现代多核处理器的一个特性），
                     所以在程序执行过程中，一个线程看到的变量不一定是最新的。）
关键字volatile 可以修饰字段（成员变量），就是告知程序任何对变量的访问均需要从共享内存里面来获取
而对于它的修改必须同步的刷新回共享内存，它能够保证所有的线程对变量的访问的可见性。
过多的使用volatile是不必要的，因为它会降低程序执行的效率。
关键字synchronized可以修饰方法或者同步代码块，它主要多个线程在同一个时刻，只能有一个线程处于方法或者同步代码块里面，
它保证了线程对变量的可见性和排他性。

任意线程对Object（Object由synchronized保护）的访问，首先得获得Object的监视器，如果获取失败，线程进入同步队列
，线程状态变为BLOCKED,。当访问Object的前驱（获得了锁的线程）释放了锁，则该释放操作唤醒阻塞在同步队列里面的线程
使其重新尝试对监视器的获取。

通知等待机制：一个线程A调用了对象O的wait()方法而进入到了等待状态，而另一个线程
B则调用了对象O的notify()或者notifyAll()方法，线程A收到了通知后，从对象A的wait方法返回，进而执行后续的操作
同步代码块对象如同锁，持有锁的线程可以在同步语句中执行；没有持有锁的线程即使获得了CPU执行权，也进不去，无法执行同步代码。
     同步函数使用的锁是this对象；静态同步函数使用的锁是该函数所在类对应的类字节码文件对象，即类名.class，该对象的类型是Class。
      synchronized修饰符不属于方法签名的一部分，当子类覆盖父类方法时，synchronized修饰符不会被继承，因此接口中方法不能被声明为synchronized，
      同样，构造函数也不能被声明为synchronized。
