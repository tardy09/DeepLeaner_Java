对于基本的奖金的计算，由于
计算奖金的 逻辑显得过于复杂，而且需要在
不同的情况下进行不同的运算操作，为了灵活性的考虑将多种计算奖金
的方式分散到不同的装饰器对象里面，采用计算组合的方式来给
基本的计算奖金的对象动态的添加计算奖金的功能，
每个装饰器相当于计算奖金的一部分，

为了达到一层一层组装的效果，装饰器还要求实现和被装饰对象相同的业务业务接口，
这样才能以一种相同的方式依次组合下去，
另外，灵活性还体现在动态上，如何使用继承的话，那么所有的装饰器类
都具有这个功能了，而采用装饰器模式，还可以动态的为几个对象实例添加功能，而不是整个类添加功能，
比如上面的计算奖金，对于张三和李四就组合了两个功能，而对于王五则组合三个功能。

装饰器模式能够从一个系统的外部来给对象添加功能，相当于改变了系统的外观，
因此，当装饰过后，从外部使用系统的角度而言，就不再是使用原始的那个对象了
，而是使用一系列的装饰器装饰过的对象。
在Java里面典型的装饰器的使用要属IO流，--装饰器和具体的组件类都需要实现同样的组件接口
1.InputStream相当于装饰器模式里面的Conponent
2.FileInputStream相当于原始的被装饰的对象
3.BufferedInputStram和DataInputStrem相当于装饰器---ConcreteDecorator
4.而FilterInputStream相当于抽象的装饰器父类----》Decorator

类似的输出流部分也类似，不再敖述
另外，装饰器模式可以随意组合




