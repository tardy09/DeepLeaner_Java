等待方（消费者）
等待方遵循如下的原则：
  1.获取对象的锁
  2.如果条件不满足，那么调用对象的wait()方法，被通知后仍然要检查条件
  3.如果条件满足则执行对应的逻辑

  对应的伪代码：
  synchronized(对象){
     while(条件不满足){
       对象.wait()...
     }
     对象的逻辑处理--已经从等待状态唤醒
  }

  通知方伪代码：
  1.获得对象的锁：
  2.改变条件
  3.通知所有的等待在对象上的线程

  对应的伪代码如下：
   synchronized(对象){
     改变条件
     对象.notifyALL();
   }

   线程的应用：
   开发人员通常遇到这样的应用场景，调用一个方法的时候等待一段时间（一般而言是给定一个时间段），
   如果方法能够在给定的时间段之内得得到结果，则将结果直接返回，反之，返回超时默认结果
   前面的通知等待模式在这里不能实现等待超时，需要对前面的通知等待模式加以修改
   假设超时时间为T,那么可以推断在当前时间now+T之后就会超时
   定义如下变量：
   1.等待超时时间 :REMAINING=T
   2.超时时间：FUTURE=now+T
   这里仅仅需要wait(REMAINING)即可，在wait(REMAINING)返回之后将会执行REMAINING=FUTURE-Now
   如果REMAINING小于0，则表示直接已经超时，直接退出，否则继续运行
